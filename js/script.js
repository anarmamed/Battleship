var model = {       // Объект model, определяет размер игрового поля, колличества кораблей, длинну кораблей и колличество потопленных кораблей
    boardSize: 7,   // размер сетки игрового поля.
    numShips: 3,    // количество кораблей в игре.
    shipLength: 3,  // длина каждого корабля (в клетках)
    shipsSunk: 0,   // количество потопленных кораблей.

// Свойство ships, содержит в себе массив с объектами(кораблями), которые в свою очередь, содержат в себе свойства locations(координаты кораблей) и hits(координаты выстрелов)    
    ships: [{ locations: [0, 0, 0], hits: ["", "", ""] },
            { locations: [0, 0, 0], hits: ["", "", ""] },
            { locations: [0, 0, 0], hits: ["", "", ""] }],

// Метод generateShip, создает один корабль, находящийся в произвольном месте игрового поля:
    generateShip: function() { 
        var direction = Math.floor(Math.random() * 2);  // Math.random генерирует число от 0 до 1 и умножает результат на 2, чтобы получить число в диапазоне от 0 до 2 (не включая 2). Затем Math.floor преобразует результат в 0 или 1.
        var row, col;
        if (direction === 1) {  // Если значение direction равно 1, создается горизонтальный корабль
                row = Math.floor(Math.random() * this.boardSize);   // генерируется начальная позиция (первая), а остальные позиции будут просто находиться в двух соседних столбцах (при горизонтальном расположении) или строках (при вертикальном расположении).
                col = Math.floor(Math.random() * (this.boardSize - this.shipLength));   // уменьшаем размер доски (boardSize) на (shipLength), чтобы начальный столбец всегда лежал в диапазоне от 0 до 4
            } else {    // Если значение direction равно 0, создается вертикальный корабль
                row = Math.floor(Math.random() * (this.boardSize - this.shipLength));
                col = Math.floor(Math.random() * this.boardSize);
            }
        var newShipLocations = [];   // Набор позиций нового корабля начинается с пустого массива, в который последовательно добавляются элементы.
        for (var i = 0; i < this.shipLength; i++) { 
            if (direction === 1) {
                newShipLocations.push(row + "" + (col + i));    // добавляем(push) в массив горизонтальный корабль. При первой итерации i равно 0, и сумма обозначает начальный столбец. При второй итерации происходит переход к следующему столбцу, а при третьей — к следующему за ним. Так в массиве генерируются серии элементов “01”, “02”, “03”.
            } else {
                newShipLocations.push((row + i) + "" + col);    // увеличивается строка — при каждой итерации цикла к ней прибавляется i.
            }
        }
        return newShipLocations;    // Когда все позиции сгенерированы, метод возвращает массив
    },

// Метод generateShipLocations, проверяет не перекрывают ли друг друга созданные корабли:
    generateShipLocations: function() { 
        var locations;  // массив позиций нового корабля, который будет размещен на игровом поле
        for (var i = 0; i < this.numShips; i++) { 
            do {
                locations = this.generateShip(); // генерируется новый набор позиций
            } while (this.collision(locations));    // проверяется, перекрываются ли эти позиции с существующими кораблями на доске. Если есть перекрытия, нужна еще одна попытка.
                this.ships[i].locations = locations;    // полученные позиции без перекрытий сохраняются в свойстве locations, объекта корабля в массиве model.ships
        }
    },

// Метод collision, получает данные корабля и проверяет, перекрывается ли хотя бы одна клетка с клетками других кораблей, уже находящихся на поле.
    collision: function(locations) {    
        for (var i = 0; i < this.numShips; i++) {  
            var ship = model.ships[i];   // Для каждого корабля, уже находящегося на поле...
            for (var j = 0; j < locations.length; j++) {    //...проверить, встречается ли какая-либо из позиций массива locations нового корабля в массиве locations существующих кораблей.
                if (ship.locations.indexOf(locations[j]) >= 0) {    // если полученный индекс больше либо равен 0, мы знаем, что клетка уже занята, поэтому метод возвращает true (перекрытие обнаружено)
            return true;
                }
            }
        }
    // Если выполнение дошло до этой точки, значит, ни одна из позиций не была обнаружена в других массивах, поэтому функция возвращает false (перекрытия отсутствуют)
        return false;   
    },

// Метод fire, получает координаты выстрела от игрока и определяет попал ли он в корабль, так же, определяет потоплен ли корабль:
    fire: function(guess) {    
        for (var i = 0; i < this.numShips; i++) {   
            var ship = this.ships[i];   // Получаем объект корабля с индексом из свойства ships
            var index = ship.locations.indexOf(guess);   // Метод indexOf ищет в массиве указанное значение и возвращает его индекс (или -1, если значение отсутствует в массиве).
            if (index >= 0) {   // Если полученный индекс из массива locations больше либо равен нулю, то
                ship.hits[index] = "hit";   // Индексу из массива hits присваивается значение "hit" 
                view.displayHit(guess);     // Сообщаем объекту view что в клетке guess следует вывести маркер попадания "hit"
                view.displayMessage("Попадание в цель!");    // Приказываем объекту view вывести сообщение с помощью метода displayMessage
                if (this.isSunk(ship)) {    // Если метод isSunk(ship) возвращает true, то есть корабль потоплен, то...
                    view.displayMessage("Вы потопили мой корабль!");   // Приказываем объекту view вывести сообщение с помощью метода displayMessage
                    this.shipsSunk++;   // Увеличиваем кол-во потопленных кораблей на один
                }
                return true;    // Возвращает true, если индекс больше либо равен нулю 
            }
        }
        view.displayMiss(guess);    // Сообщаем объекту view что в клетке guess следует вывести маркер промаха "miss"
        view.displayMessage("Вы промахнулись"); // // Приказываем объекту view вывести сообщение с помощью метода displayMessage
        return false;   //Если после перебора всех кораблей попадание не обнаружено, метод возвращает false
    },

// Метод isSunk, возвращает в метод fire - true, если корабль потоплен, или false, если он еще держится на плаву:
    isSunk: function(ship) {    
        for (var i = 0; i < this.shipLength; i++) { // перебераем объект корабля до тех пор пока не закончится его длина(3 клетки)
            if (ship.hits[i] !== "hit") {   // проверяем, помечены ли все его клетки маркером "hit", если есть хотя бы одна клетка, в которую еще не попал игрок, то корабль еще жив и...
                return false;               // ...метод возвращает false
            }
        }
        return true;   // если да - корабль потоплен.
    }
    
};  // конец объекта model



var view = {    // Объект "Представление" - отвечает за визуальный вид игры: выводит сообщения для пользователя, отмечает маркерами попадания и промахи
    displayMessage: function(msg) {     // Метод displayMessage выводит сообщение для пользователя. Получает аргумент msg(текст сообщения).
        var messageArea = document.getElementById("messageArea");   // Получаю элемент <div id="messageArea"> из DOM и присваиваю его переменной var messageArea.
        messageArea.innerHTML = msg;    // Изменяю значение элемента messageArea, через его свойство innerHTML, на значение текстового сообщения msg.
    },
    displayHit: function(location) {    // Метод displayHit принимает аргумент(координаты выстрела введенные пользователем),который образуется из строки и столбца и совпадает с идентификатором элемента <td>(ячейка в таблице).
        var cell = document.getElementById(location);   // Получаю ссылку на элемент, которому соответсвует аргумент(координаты выстрела введенные пользователем), то есть на элемент <td> с идентификатором соответсвующиму введенным пользователем координатам
        cell.setAttribute("class", "hit");  // Метод setAttribute назначает класс "hit"(прописан в CSS) элементу cell, то есть элементу <td> с идентификатором соответсвующиму введенным пользователем координатам.
    },
    displayMiss: function(location) {   // Метод displayHit принимает аргумент(координаты выстрела введенные пользователем),то есть на элемент <td> с идентификатором соответсвующиму введенным пользователем координатам
        var cell = document.getElementById(location);   // Получаю ссылку на элемент, которому соответсвует аргумент(координаты выстрела введенные пользователем) 
        cell.setAttribute("class", "miss");    // Метод setAttribute назначает класс "miss"(прописан в CSS) элементу cell, то есть элементу <td> с идентификатором соответсвующиму введенным пользователем координатам)
    }
};



// Объект controller, получает координаты выстрела, обрабатывает их и передает методу fire. Так же завершает игру.
var controller = {  
    guesses: 0,    // свойство guesses - колличество выстрелов произведенных игроком, изначально равно нулю

// Метод processGuess, получает координаты выстрела от игрока(guess) в формате “A0", "B1", "C4"...    
    processGuess: function(guess) {    
        var location = parseGuess(guess);   
        if (location){     // если location,то есть метод parseGuess(guess) вернул true, то...
            this.guesses++;    // увеличиваем колличество выстрелов(guesses) на единицу
            var hit = model.fire(location);   // координаты выстрела(guess) в виде строки("A0") передаются методу fire и присваиваются переменной hit
            if (hit && model.shipsSunk === model.numShips) {  // если model.fire(location)- true, то есть выстрел попал в цель, и количество потопленных кораблей равно количеству кораблей в игре, то
                view.displayMessage("Вы потопили все корабли, за " + this.guesses + " выстрелов");
            }   
        }
    }
}


// Функция parseGuess, получает координаты выстрела от игрока и проверяет их на действительность:
function parseGuess(guess) {    
    var alphabet = ["A", "B", "C", "D", "E", "F", "G"]; // массив с буквами, которые могут присутствовать в действительных координатах
    if (guess === null || guess.length !== 2) {     // Проверяем данные на null и убеждаемся, что в строке два символа
        alert("Ошибка! Введите заглавную букву и цифру");
    } else {
        firstChar = guess.charAt(0);    // Извлекаем первый символ строки из координат выстрела от игрока(A0) при помощи метода charAt
        var row = alphabet.indexOf(firstChar);  // При помощи метода indexOf получаем цифру соответствующую извлеченному символу(букве).
        var column = guess.charAt(1);   // Получаем второй символ из строки("A0") представляющий столбец игрового поля
        if (isNaN(row) || isNaN(column)) {  //Функция isNaN выявляет строки и столбцы, которые не являются цифрами
            alert("Ошибка! Введите корректные данные");

        // Проверка. Цифры лежат в диапазоне от 0 до 6 и не выходят за размеры игрового поля
        } else if (row < 0 || row >= model.boardSize || column < 0 || column >= model.boardSize) { 
            alert("Ошибка! Введите корректные данные");
        } else {
            return row + column;  // row — число, а column — строка, поэтому результат преобразуется в строку(конкатенация).
        }
    }
    return null;  // если какая-то проверка не прошла, то метод возвращает null.
}


 // функция будет вызываться при каждом клике на кнопке Fire:
function handleFireButton() {  
    var guessInput = document.getElementById("guessInput"); // получаем ссылку на элемент формы по идентификатору элемента, “guessInput”
    var guess = guessInput.value;   // извлекаем данные, введенные пользователем. Координаты хранятся в свойстве value элемента input
    controller.processGuess(guess); // передаем данные введенные пользователем контроллеру, точнее его методу processGuess 
    guessInput.value = "";  // команда просто удаляет содержимое элемента input формы, заменяя его пустой строкой. Это делается для того, чтобы приходилось многократно выделять текст и удалять его перед вводом следующего выстрела.
}


// Обработчик нажатий клавиш вызывается при каждом нажатии клавиши в поле input страницы:
function handleKeyPress(e) {    
    var fireButton = document.getElementById("fireButton");
    if (e.keyCode === 13) {     // Если нажата клавиша Enter, то  кнопка Fire должна сработать так, словно игрок щелкнул на ней.
    fireButton.click();
    return false;
    }
}


window.onload = init; // браузер выполнит init, только при полной загрузке страницы.

function init() {     

// Связывает обработчик событий с кнопкой Fire
    var fireButton = document.getElementById("fireButton"); 
    fireButton.onclick = handleFireButton;  //назначаем обработчик события нажатия — вызываем функцию handleFireButton нажатием на кнопку Fire
   
// Связываем обработчик событий с нажатием клавиши Enter в поле input
    var guessInput = document.getElementById("guessInput"); 
    guessInput.onkeypress = handleKeyPress; //Добавляем новый обработчик событий нажатия клавиш в поле ввода HTML.

// При таком вызове, позиции всех кораблей будут определены к моменту начала игры. 
    model.generateShipLocations(); 
}






// // Глобальный объект ships(корабли)
// var ships = [{locations: ["10", "20", "30"], hits: ["", "", ""] },  // Переменная ships(корабли) ссылается на объект с массивом, внутри которого три объекта представляющих корабль №1, 2 и 3. 
//             { locations: ["32", "33", "34"], hits: ["", "", ""] },  // Каждый объект содержит в себе массив locations(координаты) и массив hits(попадания) с тремя элементами внутри. 
//             { locations: ["63", "64", "65"], hits: ["", "", ""] }],
// // тестовая проверка
// var ship3 = ships[2];   // объект, с индексом 2(третий корабль), из массива объекта ships, помещается в переменную ship3  
// var hit3 = ship3.hits;  // в переменную hit3 помещается массив hits принадлежащий третьему кораблю(ship3) 
//     hit3[1] = "hit";    // в массив hits представленный переменной hit3 помещается значение "hit" под индексом 1(второе значение)
//     if (hit3[1] === "hit") {    // если в массиве hits под индексом 1 находится значение "hit", то...
//         console.log("Попадание в середину третьего корабля!");
//     } else {    // иначе...
//         console.log("Мимо! Попробуйте еще раз"); 
// }



// // Примитивный морской бой с полем на 7 клеток и одним кораблем (используются функции prompt, alert)

// let randomLoc = Math.floor(Math.random() * 5), // функция Math.random() создает сулчайное число от 0 до 0.999. Умножение на 5 создает число от 0 до 4.999. Math.floor - округляет число в меньшую сторону - 4.999 будет 4
//     location1 = randomLoc, // позиции №1 присваивается случайная позиция
//     location2 = location1 + 1, // позиции №2 присваивается значение позиции №1 увеличенной на единицу
//     location3 = location2 + 1, // позиции №3 присваивается значение позиции №2 увеличенной на единицу
//     guess, // значение выстрела пользователя изначально undefined
//     hits = 0, //  колличество попаданий
//     guesses = 0, // количество попыток
//     isSunk = false; // корабль потоплен - ложь

// while (isSunk == false) { // Цикл while с условием, если переменная isSunk равна false выполнится потому что isSunk = false
//     guess = prompt("Ваш выстрел! (введите число от 0 до 6)");
//     if (guess < 0 || guess > 6) {
//         alert("Введите правильное значение (0-6)");
//         } else {
//                 guesses = guesses + 1; // увеличивает колличесвто попыток на один

//         if (guess == location1 || guess == location2 || guess == location3) {
//             alert("Попадание в цель!");
//             hits = hits + 1; // увеличивает кол-во попаданий на один

//         if (hits == 3) {
//             isSunk = true; // переменная становится true если кол-во попаданий равняется трем
//             alert("Вы потопили мой корабль!");
//          }
//     } else {
//         alert("Мимо!");
//       }
//     }
// }

// let stats = "Вы сипользовали " + guesses + " попыток, что бы потопить корабль. " +
// "Ваша точность составляет: " + (300/guesses).toFixed() + "%";
// alert(stats);
